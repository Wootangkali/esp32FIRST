
// // //FULL DEMO
// // #pragma once

// Scanning...
// I2C device found at address 0x20 !
// I2C device found at address 0x3F !
// I2C device found at address 0x68 !
// done
// #include <arduino.h>
//// WiFi
#include <Arduino.h>
 #include <Wire.h>




#include <LittleFS.h>
#include <UnixTime.h>
#include <PairsFile.h>
PairsFile conFile(&LittleFS, "/data2.dat", 3000);
// PairsFile conFile(&GH_FS, "/data.dat", 3000);
#define GH_FS LittleFS
#include <PubSubClient.h>
 #define GH_NO_MQTT
#define GH_INCLUDE_PORTAL
#define GH_FILE_PORTAL
#include <GyverTimer.h> 
// #include <GyverTimers.h>
#include <GyverHub.h>
 #include <GSON.h>
#include <Stamp.h>
 #include <TimerMs.h>

 static uint32_t Stamps;

UnixTime stamp(0);  // указать GMT (3 для Москвы)

#include <WIFI.h>
#include <WiFiClientSecure.h>


#define AP_SSID "TP-LINK"
#define AP_PASS "214365Qq"
#define WIFI_TIMEOUT_MS 20000
#define WIFI_NETWORK "TP-LINK"
#define WIFI_PASSWORD "214365Qq"
// базовый пример работы с библиотекой, основные возможности. Загрузи и изучай код
// WiFi
const char *ssid = "TP-LINK"; // Enter your Wi-Fi name
const char *password = "214365Qq";  // Enter Wi-Fi password

// MQTT Broker
const char *mqtt_broker = "m8.wqtt.ru";
const char *topic = "topic/esp32";
const char *TEMPR = "topic/TR";
const char *TEMPW = "topic/TW";

const char *mqtt_username = "wootang";
const char *mqtt_password = "398958";
const int mqtt_port = 14396;



// // отключаем встроенную реализацию MQTT (для esp)

// // MQTT
// const char* mqtt_server = "m8.wqtt.ru";
// const int mqtt_port = 14396;
// const char* mqtt_user = "wootang";
// const char* mqtt_password = "398958";
//  String client_id = "esp32";
// // SENSOR
 const int sending_period = 25;
const bool retain_flag = true;
const char* Wtemp_topic = "Wtempt";
const char* ventel_topic = "ventelt";
const char* Rtemp_topic = "Rtempt";
const char* Rtemp2_topic = "Rtemp2t";
int pwm27;

const char* pwm27_topic = "pwm27t";

const int pwmv = 27;
// int ventpin = 27; 

int pwm27new;

int brightness = 0;
int step = 5;


const char* waterSENS_topic = "waterSENSt";
const char* dolivSENS_topic = "dolivSENSt";
const char* val_utechkaD_topic = "val_utechkaDt";
// const char *topic = "topic/esp32";
// const char *TEMPR = "topic/TR";
// const char *TEMPW = "topic/TW";
// /////////////////////////////////////////////////////////


//

WiFiClient espClient;
PubSubClient client(espClient);




// // логин-пароль от роутера


GyverHub hub;

#include "ThingSpeak.h"

#define CHANNEL_ID 1551807
#define CHANNEL_API_KEY "EZVNSKEUD4RWXAAD"


#define CHANNEL_ID2 1628917
#define CHANNEL_API_KEY2 "R5VFO73Q37GESE3V"

uint32_t rndColor() {
    uint32_t colors[] = {
        0xcb2839,
        0xd55f30,
        0xd69d27,
        0x37A93C,
        0x25b18f,
        0x2ba1cd,
        0x297bcd,
        0x825ae7,
        0xc8589a,
    };
    return colors[random(9)];
};
String rndText() {
    String s;
    uint8_t len = random(5, 12);
    for (uint8_t i = 0; i < len; i++) {
        s += (char)random('a', 'z');
    };
    return s;
};
gh::Align rndAlign() {
    static uint8_t i;
    if (++i >= 3) i = 0;
    return (gh::Align)i;
};
const char* rndIcon() {
    static uint8_t i;
    if (++i >= 4) i = 0;
    const char* icons[] = {
        "",
        "f0ad",
        "f5ce",
        "",
    };
    return icons[i];
};



// WiFiClient client;
// MQTTPubSubClient mqtt;

 #include "PCF8575.h"

 // Set i2c address
 PCF8575 pcf1(0x20);
 PCF8575 pcf2(0x22);

 float Temperatura;

   bool autos=1;

String messager = "";
String messagew = "";
 
 
 // СТУПЕНИ ТЕМПЕРАТУРЫ ВЕНТЕЛЯ
 float vent0=22.0;
 float vent1=23.0;
 float vent2=24.0;
 float vent3=26.5;
 float vent4=27.5;
 float vent5=28.0;
 float vent6=29.5;
 float vent7=30.5;
 float vent8=31.5;
 float vent9=32.5;
 // СТУПЕНИ ВЕНТЕЛЯ
  float ventob0=85;
 float ventob1=95;
 float ventob2=100;
 float ventob3=100;
 float ventob4=100;
 float ventob5=100;
 float ventob6=110;
 float ventob7=120;
 float ventob8=130;
float ventob9=140;


float volt;

float pwm100;

 float ventel=0 ;

   float ventday;

 float ventup = 11.00;
  float ventdown = 23.00;

 int timePoliv = 40000;
 int timeDoliv = 180000;


  float ventdd;




#include <NTPClient.h>
#include <WiFiUdp.h>
// Define NTP Client to get time
WiFiUDP ntpUDP;
NTPClient timeClient(ntpUDP, "pool.ntp.org");

//Week Days
String weekDays[7]={"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"};

//Month names
String months[12]={"January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"};


time_t epochTime;



const int vdnpin = 16;

 const int capteur_D = 19;   //DIGITAL UTECHKA
 const int capteur_A = 18;    //ANALOG UTECHKA

// int ventpin = 27;           // контакт ШИМ, к которому подключен светодиод

//  const int UTECHKA_PIN = 5;   //PIN UTECHKA
 int val_utechka;
 int val_utechkaD;

 // (период, мс), (0 не запущен / 1 запущен), (режим: 0 период / 1 таймер)
 TimerMs tmr(5000, 1, 0);
 // TimerMs dolivpause(3000, 1, 1);
 TimerMs textp(15000, 1, 0);
 TimerMs tmrWF(20000, 1, 0);
 // TimerMs WATERPING(5000, 1, 0);
  TimerMs tmrvent(25000, 1, 0);


  TimerMs tmrug(1000, 1, 0);


//  GTimer dolivpause(MS);  // можно сразу указать период (по умолч. в режиме интервала)
//  GTimer polivtimer(MS);  // можно сразу указать период (по умолч. в режиме интервала)


 // int value = 0;
 unsigned long next_time; // время очередного переключения первого светодиода
 int timeout = 2500; // половина периода мигания
 //int led_state = 0; // начальное состояние светодиода - выключен


 int DP=1;
 // int grelka_PIN;
 bool grelka;



 bool obogrev;
 bool obogrevt;


 // Текущее состояние сенсора
 bool SensorStateWS = HIGH;
 // Время начала смены
 unsigned long SensorStartChangeWS = 0;
 // Защитный интервал между сменами состояния
 unsigned long TIMEOUTWS = 1000;
 // Текущее время
 unsigned long CurrentTimeWS = 0;



 // Текущее состояние сенсора
 bool SensorStateDS = HIGH;
 // Время начала смены
 unsigned long SensorStartChangeDS = 0;
 // Защитный интервал между сменами состояния
 unsigned long TIMEOUTDS = 2000;
 // Текущее время
 unsigned long CurrentTimeDS = 0;

 // Пример использования библиотеки GyverButton, все возможности в одном скетче.
 // автоматический тик


 #include "Button2.h"

 // Button2 button;
 byte pin = 2;
 /////////////////////////////////////////////////////////////////

 Button2 button;
  #define BUTTON_PIN  2


 #include <OneWire.h>
 #include <DallasTemperature.h>

 #define ONE_WIRE_BUS 0
#define TEMPERATURE_PRECISION 12 // Lower resolution
OneWire oneWire(ONE_WIRE_BUS);

DallasTemperature sensors(&oneWire);

 DeviceAddress outsideThermometer = { 0x28, 0x52, 0x37, 0x14, 0x64, 0x20, 0x01, 0x19 };  //28 D6 B5 3D 9 0 0 AE
DeviceAddress  insideThermometer  = { 0x28, 0xFA, 0xED, 0x23, 0x64, 0x20, 0x01, 0xC9 };
DeviceAddress  ROOMThermometer  = { 0x28, 0xD6, 0xB5, 0x3D, 0x09, 0x00, 0x00, 0xAE };

// ROM = 28 52 37 14 64 20 1 19
//   Chip = DS18B20
//   Data = 1 9A 1 4B 46 7F FF 7F 10 7C  CRC=7C
//   Temperature = 25.62 Celsius, 78.12 Fahrenheit
// ROM = 28 FA ED 23 64 20 1 C9
//   Chip = DS18B20
//   Data = 1 72 1 4B 46 7F FF 7F 10 25  CRC=25
//   Temperature = 23.12 Celsius, 73.62 Fahrenheit
// ROM = 28 D6 B5 3D 9 0 0 AE
//   Chip = DS18B20
//   Data = 1 78 1 4B 46 7F FF 8 10 51  CRC=51
//   Temperature = 23.50 Celsius, 74.30 Fahrenheit

   float Wtemp; // temperature in Celsius
 int dolivSENS;
 int waterSENS;
 int podachawater;
 int polivpompa;

bool dolivSE;
bool waterSE;

 float poliv;


  int dolivpompa;
 float Rtemp; // temperature in Celsius

float Rtemp2; // temperature in Celsius


uint8_t tab=0;




// int dat;
// int tim;
// // // отключаем встроенную реализацию MQTT (для esp)

// // // MQTT
// // const char* mqtt_server = "m8.wqtt.ru";
// // const int mqtt_port = 14396;
// // const char* mqtt_user = "wootang";
// // const char* mqtt_password = "398958";

// // // SENSOR
//  const int sending_period = 5;
// const bool retain_flag = false;
// const char* Wtemp_topic = "esp/Wtemp";
// const char* ventel_topic = "esp/ventel";
// const char* Rtemp_topic = "esp/Rtemp";


// const char *topic = "topic/esp32";
// const char *TEMPR = "topic/TR";
// const char *TEMPW = "topic/TW";
// // /////////////////////////////////////////////////////////


// WiFiClient espClient;
// PubSubClient client(espClient);

uint32_t tmr1;


// bool relay_on = false;

void reconnect() {
  while (!client.connected()) {
    Serial.print("Attempting MQTT connection...");
    String clientId = "ESP32-" + WiFi.macAddress();
    if (client.connect(clientId.c_str(), mqtt_username, mqtt_password) ) {
      Serial.println("connected");
      digitalWrite(vdnpin,  HIGH);
    } else {
      Serial.print("failed, rc=");
      Serial.print(client.state());
      Serial.println(" try again in 5 seconds");
      // delay(5000);
    }
  }
};

// // обновить панель управления в приложении
void sendRefresh(gh::Client* client = nullptr)
{

};



 void pressed(Button2& btn) {
     Serial.println("pressed");
    	// pcf8575.digitalWrite(P3, LOW);
     poliv=1;
 //  dolivpause.setTimeout(timeDoliv);       //  пауза долива и подогрева
 //   polivtimer.setTimeout(timePoliv);

 };
 void released(Button2& btn) {
     Serial.print("released: ");
     Serial.println(btn.wasPressedFor());
    
           	// pcf8575.digitalWrite(P3, LOW);
 //  dolivpause.setTimeout(timeDoliv);       //  пауза долива и подогрева
 //   polivtimer.setTimeout(timePoliv);
 };
 void changed(Button2& btn) {
     Serial.println("changed");
 };
 void click(Button2& btn) {
     Serial.println("click\n");
         poliv=1;
        	// pcf8575.digitalWrite(P3, LOW);
 //  dolivpause.setTimeout(timeDoliv);       //  пауза долива и подогрева
 //   polivtimer.setTimeout(timePoliv);
 };
 void longClickDetected(Button2& btn) {
     Serial.println("long click detected");
     poliv=0;
 };
 void longClick(Button2& btn) {
     Serial.println("long click\n");
         poliv=0;
    	// pcf8575.digitalWrite(P3, HIGH);
 };
 void doubleClick(Button2& btn) {
     Serial.println("double click\n");
         poliv=1;
         // pcf8575.digitalWrite(P3, LOW);

 //  dolivpause.setTimeout(timeDoliv);       //  пауза долива и подогрева
 //   polivtimer.setTimeout(timePoliv);
 };
 void tripleClick(Button2& btn) {
     Serial.println("triple click\n");
     Serial.println(btn.getNumberOfClicks());
         poliv=0;
 };
 void tap(Button2& btn) {
     Serial.println("tap");
     poliv=1;
 };



// void build_mqtt(gh::Builder& b) {
//     static String s1, s2;
//     if (b.Input_("mqinp", &s1).click()) {
//         Serial.print("mqinp set to: ");
//         Serial.println(b.build.value);
//     }
//     if (b.Dummy_("dummy", &s2).click()) {
//         Serial.print("dummy set to: ");
//         Serial.println(b.build.value);
//     }
//     if (b.Button().click()) hub.sendGetStr("dummy", String(random(100) / 10.0, 2));
// }









// обработчик кнопки (см. ниже)
void btn_cb() {
    Serial.println("AUTO ON");
        if (Rtemp <= vent0 && Rtemp <= vent1 ) {
 ventel=0;
   };

     if (Rtemp >= vent1 && Rtemp <= vent2 ) {
   ventel=1;
    };

  if (Rtemp >= vent2 && Rtemp <= vent3) {
 ventel=2;
     
   };

  if (Rtemp >= vent3 && Rtemp <= vent4) {
 ventel=3;
        };


    if (Rtemp >= vent4 && Rtemp <= vent5) {
 	ventel=4;
   };


    if (Rtemp >= vent5 && Rtemp <= vent6) {
 	ventel=5;
    };

    if (Rtemp >= vent6 && Rtemp <= vent7) {
   	ventel=6;
         };
    
     if (Rtemp >= vent7 && Rtemp <= vent8) {
 	ventel=7; 
  };

  if (Rtemp >= vent8 && Rtemp <= vent9) {
 	ventel=8;
  };
    if (Rtemp >= vent9) {
 	ventel=9;
     };
// hub.refresh();
};





// обработчик кнопки с информацией о билде (см. ниже)
void btn_cb_b(gh::Build& b) {
    Serial.print("click 5 from client ID: ");
    Serial.println(b.client.id);
    // b.refresh();
};



// билдер
// void build(gh::Builder& b) {
    // =================== КОНТЕЙНЕРЫ ===================
void build(gh::Builder& b) {




    if (b.beginRow()) {

  b.Slider(&vent0).label(F("VENT0")).color(gh::Colors::Red).size(1).range(20, 26, 0.5);
       b.endRow();   }
        if (b.beginRow()) {
   b.Slider(&vent1).label(F("VENT1")).color(gh::Colors::Red).size(1).range(22, 27, 0.5);
 b.endRow();   }
        if (b.beginRow()) {
    b.Slider(&vent2).label(F("VENT2")).color(gh::Colors::Red).size(1).range(23, 28, 0.5);
 b.endRow();   }
        if (b.beginRow()) {
     b.Slider(&vent3).label(F("VENT3")).color(gh::Colors::Red).size(1).range(23.5, 29, 0.5);
 b.endRow();   }
        if (b.beginRow()) {
      b.Slider(&vent4).label(F("VENT4")).color(gh::Colors::Red).size(1).range(24, 30, 0.5);
 b.endRow();   }
        if (b.beginRow()) {
       b.Slider(&vent5).label(F("VENT5")).color(gh::Colors::Red).size(1).range(24.5, 31, 0.5);
 b.endRow();   }
        if (b.beginRow()) {
        b.Slider(&vent6).label(F("VENT6")).color(gh::Colors::Red).size(1).range(25, 32, 0.5);
 b.endRow();   }
        if (b.beginRow()) {
         b.Slider(&vent7).label(F("VENT7")).color(gh::Colors::Red).size(1).range(25.5, 33, 0.5);
 b.endRow();   }
        if (b.beginRow()) {
          b.Slider(&vent8).label(F("VENT8")).color(gh::Colors::Red).size(1).range(26, 34, 0.5);

       b.endRow();
    }
if (b.beginRow()) {
          b.Slider(&vent9).label(F("VENT9")).color(gh::Colors::Red).size(1).range(26.5, 34, 0.5);

       b.endRow();
    }
    b.refresh();
};
// }

void build_1(gh::Builder& b) {
 if (b.beginRow()) {

  b.Slider(&ventob0).label(F("ОБОРОТЫ-0")).color(gh::Colors::Blue).size(1).range(50, 125, 1);
   b.endRow();   }
        if (b.beginRow()) {
   b.Slider(&ventob1).label(F("ОБОРОТЫ-1")).color(gh::Colors::Blue).size(1).range(80, 140, 1);
    b.endRow();   }
        if (b.beginRow()) {
    b.Slider(&ventob2).label(F("ОБОРОТЫ-2")).color(gh::Colors::Blue).size(1).range(90, 160, 1);
     b.endRow();   }
        if (b.beginRow()) {
     b.Slider(&ventob3).label(F("ОБОРОТЫ-3")).color(gh::Colors::Blue).size(1).range(90, 150, 1);
      b.endRow();   }
        if (b.beginRow()) {
      b.Slider(&ventob4).label(F("ОБОРОТЫ-4")).color(gh::Colors::Blue).size(1).range(100, 180, 1);

       b.endRow();   }
        if (b.beginRow()) {
       b.Slider(&ventob5).label(F("ОБОРОТЫ-5")).color(gh::Colors::Blue).size(1).range(100, 200, 1);
        b.endRow();   }
        if (b.beginRow()) {
        b.Slider(&ventob6).label(F("ОБОРОТЫ-6")).color(gh::Colors::Blue).size(1).range(110, 220, 1);
         b.endRow();   }
        if (b.beginRow()) {
         b.Slider(&ventob7).label(F("ОБОРОТЫ-7")).color(gh::Colors::Blue).size(1).range(110, 255, 1);
          b.endRow();   }
        if (b.beginRow()) {
          b.Slider(&ventob8).label(F("ОБОРОТЫ-8")).color(gh::Colors::Blue).size(1).range(120, 255, 1);

       b.endRow();
    }
 if (b.beginRow()) {
          b.Slider(&ventob9).label(F("ОБОРОТЫ-9")).color(gh::Colors::Blue).size(1).range(130, 255, 1);

       b.endRow();
    }

b.refresh();

};

//  if (b.beginRow()) {

//   b.Slider(&ventel).label(F("СКОРОСТЬ")).color(gh::Colors::Green).size(1).range(0, 9, 1);
//       b.endRow();} 




void build_2(gh::Builder& b) {




if (b.beginRow()) {

 
  b.Slider(&Temperatura).label(F("Температура водонагревателя")).color(gh::Colors::Red).size(1).range(10, 27, 0.1, 1 );
   
  //  b.Label().label("Temperatura").size(2).valueFloat(Temperatura); 
    b.endRow();};



if (b.beginRow()) {

 
  b.Label().label("Ускорение вытяжки с").size(2).value(ventup); 
   b.Label().label("Замедление вытяжки с").size(2).value(ventdown); 
    b.endRow();};



if (b.beginRow()) {

  b.Slider(&ventup).label(F("Ускорение вытяжки с")).color(gh::Colors::Yellow).size(1).range(0, 24, 0.1, 1 );
   
    b.endRow();
    };


    if (b.beginRow()) {

  b.Slider(&ventdown).label(F("Замедление вытяжки с")).color(gh::Colors::Yellow).size(1).range(0, 24, 0.1, 1 );
   
    b.endRow();
    };



if (b.beginRow()) {

  b.Slider(&ventday).label(F("Дневное ускорение")).color(gh::Colors::Red).size(1).range(-50, 100, 1, 1 );
   
    b.endRow();
    };


   if (b.beginRow()) {
    b.Label().label("℃ верх").size(2).value(Rtemp);   // с указанием стандартного значения

    
     b.Label().label("℃ воды").size(2).value(Wtemp);   // с указанием стандартного значения
   

b.Label().label("℃ низ").size(2).value(Rtemp2);   // с указанием стандартного значения
   

  //  b.Label().label("Температура водонагревателя").size(2).valueFloat(Temperatura); 

   b.endRow();
   };


 if (b.beginRow()) {


     b.Slider(&ventel).label(F("Шаг вентиляции")).color(gh::Colors::Blue).size(1).range(0, 9, 1);


    b.endRow();
    };


//  if (b.beginRow()) {
//         b.Label_("PWM")).size(2).valueInt(pwm27);  // с указанием стандартного значения

//       b.Label_(F("Volt")).size(2).valueInt(volt);  // с указанием стандартного значения

//         b.endRow();
//     }



// (&vent1).label(F("VENT1"))

 if (b.beginRow()) {
        // b.Label.label("pwm27").valueInt(pwm27);;  // с указанием стандартного значения

   b.Label().label("volt").size(2).value(volt);   // с указанием стандартного значения
//  b.Label().label("ШИМ").size(2).valueFloat(pwm27);   // с указанием стандартного значения
  // b.Input().label("pwm27").size(2).valueFloat(pwm27); 
  b.Label().label("%").size(2).value(pwm100);  


        b.endRow();
    };


if (b.beginRow()) {

  b.Slider(&pwm27).label(F("ШИМ вентиляци")).color(gh::Colors::Red).size(1).range(80, 255, 1);
   b.endRow();  
    };



 if (b.beginRow()) {
        // b.Input(&poliv).size(2);
   if (b.Switch(&autos).label("Режим АВТО").size(1).click()) {
Serial.println("Режим АВТО");

Serial.println(autos);


   };
        // СПОСОБ 4
        // подключить функцию-обработчик (см. выше)
        b.Button().label("Синхронизация").attach(btn_cb);
        // внутри обработки действия переменная уже будет иметь новое значение:
        if (b.Switch(&poliv).label("POLIV").size(1).click()) {
            Serial.print("poliv: ");
            Serial.println(poliv);
        };

        b.endRow();

    };
 if (b.beginRow()) {
    b.Label().label("obogrev").size(2).value(obogrev);   // с указанием стандартного значения
 if (b.Switch(&obogrev).label("obogrev").size(1).click()) {
            Serial.print("obogrev: ");
            Serial.println(obogrev);
        };
        b.endRow();

    };
// Temperatura
//  if (b.beginRow()) {
//         b.Input(&Wtemp).size(2);
//        b.endRow();
//     }
//     // =================== ПАРАМЕТРЫ ВИДЖЕТА ===================

    if (b.beginRow()) {
        // параметры виджета можно задавать цепочкой. Например:
        b.Button().label(F("my button")).color(gh::Colors::Red);

        // также можно продолжить настраивать ПРЕДЫДУЩИЙ виджет, обратившись к widget:
        b.Button();                        // кнопка без параметров
        b.widget.label(F("button 2"));     // настраиваем кнопку выше
        b.widget.color(gh::Colors::Blue);  // её же

        b.endRow();
    };

    // =================== ДЕЙСТВИЯ ВИДЖЕТА ===================

    // с активных виджетов можно получить сигнал о действии - клик или изменение значения
    if (b.beginRow()) {
        // // СПОСОБ 1
        // // проверить условие click() - он вернёт true при действии
        // // click() нужно вызывать ПОСЛЕДНИМ в цепочке!!!
        // if (b.Button().click()) Serial.println("click 1");

        // // СПОСОБ 2
        // // подключить bool переменную - флаг
        // bool flags=0;
        // b.Button().attach(&flags);
        // if (flags) Serial.println("click 2");

        // // СПОСОБ 3
        // // подключить gh::Flag переменную - флаг
        // // данный флаг сам сбросится в false при проверке!
        // gh::Flag gflag;
        // b.Button().attach(&gflag);
        // if (gflag) Serial.println("click 3");
        // // здесь gflag уже false
//    if (b.Switch(&autos).label("AUTOS").size(1).click()) {
// Serial.println("AUTOS");

// Serial.println(autos);


//    }
//         // СПОСОБ 4
//         // подключить функцию-обработчик (см. выше)
//         b.Button().attach(btn_cb);

        // СПОСОБ 5
        // подключить функцию-обработчик с инфо о билде (см. выше)
        b.Button().attach(btn_cb_b);

        // attach() может быть НЕ ПОСЛЕДНИМ в цепочке, также их может быть несколько:
        // b.Button().attach(f1).attach(f2).label("kek");

        b.endRow();
    };

    // =============== ПОДКЛЮЧЕНИЕ ПЕРЕМЕННОЙ ===============

    // if (b.beginRow()) {
    //     // библиотека позволяет подключить к активному виджету переменную для чтения и записи
    //     // я создам статические переменные для ясности. Они могут быть глобальными и так далее
    //     // таким образом изменения останутся при перезагрузке страницы
    //     // static int sld;
    //     static String inp;
      

    //     // для подключения нужно передать переменную по адресу
    //     // библиотека сама определит тип переменной и будет брать из неё значение и записывать при действиях
    //     // библиотека поддерживает все стандартные типы данных, а также некоторые свои (Pairs, Pos, Button, Log...)
    //


//  if (b.beginRow()) {
//         b.Input(&Rtemp).size(2);

//         // внутри обработки действия переменная уже будет иметь новое значение:
//         if (b.Switch(&ventel).size(1).click()) {
//             Serial.print("switch: ");
//             Serial.println(ventel);
//         }

//         b.endRow();
//     }


    // ==================== ОБНОВЛЕНИЕ ====================

    // библиотека позволяет обновлять значения на виджетах. Это можно делать
    // - из основной программы (см. ниже)
    // - из билдера - но только при действиях по виджетам!

    // для отправки обновления нужно знать ИМЯ компонента. Его можно задать почти у всех виджетов
    // к функции добавляется подчёркивание, всё остальное - как раньше

    if (b.beginRow()) {
        b.Label_(F("label")).size(2).value("default");  // с указанием стандартного значения

        if (b.Button().size(1).click()) {
            hub.update(F("label")).value(random(100, 500));
        };

        b.endRow();
    };

    // в самом низу сделаем заголовок, текст будем обновлять из loop() (см. ниже)
    b.Title_(F("title"));

    // =================== ИНФО О БИЛДЕ ===================

    // можно получить информацию о билде и клиенте для своих целей
    // поставь тут 1, чтобы включить вывод =)
    if (1) {
        // запрос информации о виджетах
        if (b.build.isUI()) {
            Serial.println("=== UI BUILD ===");
        };

        // действие с виджетом
        if (b.build.isSet()) {
            Serial.println("=== SET ===");
            Serial.print("name: ");
            Serial.println(b.build.name);
            Serial.print("value: ");
            Serial.println(b.build.value);
        };

        Serial.print("client from: ");
        // Serial.println(gh::readConnection(b.client.connection()));
          //  Serial.print(gh::readConnection(req.client.connection()));
              // Serial.print(gh::readConnection(client.connected());
        Serial.print("ID: ");
        Serial.println(b.build.client.id);
        Serial.println();  
         b.refresh();
    };
    //  b.Hook_("Wtemp", &Wtemp);
    //  b.Hook_("Rtemp2", &Rtemp2);
       
    //      b.Hook_("ventob8", &ventob8);
    //        b.Hook_("ventob7", &ventob7);
    //          b.Hook_("ventob6", &ventob6);
    //            b.Hook_("ventob5", &ventob5);
    //              b.Hook_("ventob4", &ventob4);
    //                b.Hook_("ventob3", &ventob3);
    //                  b.Hook_("ventob2", &ventob2);
    //                    b.Hook_("ventob1", &ventob1);
    //                      b.Hook_("ventob0", &ventob0);
    //                        b.Hook_("ventob9", &ventob9);
    //             //              b.Hook_("ventob", &ventob);
    //             //                b.Hook_("ventob", &ventob);
    //             //                  b.Hook_("ventob", &ventob);

             

};


void btn_grelka() {
grelka = 1;
 
      //  pcf1.digitalWrite(P2, LOW);
 if (Wtemp >= Temperatura){
grelka = 0;
 
      //  pcf1.digitalWrite(P2, HIGH);
    };
// b.refresh();

};


void build_3(gh::Builder& b) {
    // СПОСОБ 4
    if (b.beginRow()) {
        // подключить функцию-обработчик (см. выше)
         b.Label().label("grelka").size(2).value(grelka); 
        // внутри обработки действия переменная уже будет иметь новое значение:
        if (b.Switch(&grelka).label("grelka").size(1).click()) {
            Serial.print("grelka: ");
            Serial.println(grelka);
        };

        b.endRow();
    };



 if (b.beginRow()) {
    b.Label().label("waterSENS").size(2).value(waterSENS);   // с указанием стандартного значения

     b.Label().label("dolivSENS").size(2).value(dolivSENS);   // с указанием стандартного значения
   
  //  b.Label().label("Температура водонагревателя").size(2).valueFloat(Temperatura); 

   b.endRow();};


 if (b.beginRow()) {
    b.Label().label("val_utechkaD").size(2).value(val_utechkaD);   // с указанием стандартного значения

     b.Label().label("grelka").size(2).value(grelka);   // с указанием стандартного значения
   
  //  b.Label().label("Температура водонагревателя").size(2).valueFloat(Temperatura); 

   b.endRow();};


 if (b.beginRow()) {
    b.Label().label("dolivpompa").size(2).value(dolivpompa);   // с указанием стандартного значения

     b.Label().label("polivpompa").size(2).value(polivpompa);   // с указанием стандартного значения
   
  //  b.Label().label("Температура водонагревателя").size(2).valueFloat(Temperatura); 

   b.endRow();};


 if (b.beginRow()) {
    b.Label().label("переменная долива").size(2).value(DP);   // с указанием стандартного значения

    //  b.Label().label("polivpompa").size(2).valueFloat(polivpompa);   // с указанием стандартного значения
   
  //  b.Label().label("Температура водонагревателя").size(2).valueFloat(Temperatura); 

   b.endRow();}
  //  b.refresh();
};

void build_Menu(gh::Builder& b) {



  if (b.beginRow()) {  
//  Stamps = stamp;
// stamp = Stamps;
// b.DateTime(&unix);
// b.DateTime(&d);
// b.DateTime(&Stamp);
// b.DateTime(&stamp);

 Stamps = timeClient.getEpochTime();
 stamp.getDateTime(Stamps);
// stamp = Stamps;

b.DateTime(&Stamps);
  Serial.println(Stamps);
  // Serial.println(stamp);
 uint32_t unix = stamp.getUnix();
  // Serial.println(unix);

//     Serial.print("time   ");
//   Serial.print(stamp.hour);
//   Serial.print(":");
//   Serial.print(stamp.minute);
//   Serial.print(":");
//   Serial.print(stamp.second);
//   Serial.print("  ");

//    Serial.print(stamp.day);
//   Serial.print(".");
//  Serial.print(stamp.month); 
//  Serial.print(".");
//  Serial.print(stamp.year);
 
//   Serial.print("----");
//   Serial.print(stamp.dayOfWeek);

// int hour = stamp.hour;


b.refresh();
 b.endRow();
};


 

  if (b.beginRow()) {
    bool ref = false;

    ref |= b.Tabs(&tab).text(F("Main;°C;Step;int")).noLabel().size(4).click();
    if (ref) b.refresh();
    b.endRow();

    switch (tab) {
      // вкладки меню
      case 0: build_2(b);              break;
      case 1: build(b);      break;
       case 2: build_1(b);       break;
       case 3: build_3(b);           break;
      // case 4: build_SettingsRoot(b);    break;
      // меню, вызываемые по кнопкам
      // case 10: build_ManualEQ(b);       break;
      // case 11: build_SettingsEQ(b);     break;
      // case 12: build_SettingsNight(b);  break;
    };
  };
};


void callback(char *topic, byte *payload, unsigned int length) {
    Serial.print("Message arrived in topic: ");
    Serial.println(topic);
    Serial.print("Message:");
    for (int i = 0; i < length; i++) {
        Serial.print((char) payload[i]);
    };
    Serial.println();
    Serial.println("-----------------------");
};



void sendData() {




  client.publish(Wtemp_topic, String(Wtemp).c_str(), retain_flag);
  client.publish(ventel_topic, String(ventel).c_str(), retain_flag);
  client.publish(Rtemp_topic, String(Rtemp).c_str(), retain_flag);
    client.publish(Rtemp2_topic, String(Rtemp2).c_str(), retain_flag);


  client.publish(pwm27_topic, String(pwm27).c_str(), retain_flag);
  client.publish(waterSENS_topic, String(waterSENS).c_str(), retain_flag);
  client.publish(dolivSENS_topic, String(dolivSENS).c_str(), retain_flag);
  client.publish(val_utechkaD_topic, String(val_utechkaD).c_str(), retain_flag);



// //subscribe
// // client.subscribe("topic");
// // client.setCallback(callback);

// client.subscribe("Rtemp");
// client.setCallback(callback);

// client.subscribe("Wtemp");
// client.setCallback(callback);




// client.subscribe("pwm27");
// client.setCallback(callback);

// client.subscribe("waterSENS");
// client.setCallback(callback);

// client.subscribe("dolivSENS");
// client.setCallback(callback);
// client.subscribe("val_utechkaD");
// client.setCallback(callback);


};


void getDateTime(uint32_t t);   // конвертировать unix stamp дату и время (в переменные члены класса)
    
// установка даты и времени (удобнее чем писать переменные вурчную)
void setDateTime(uint16_t nyear, uint8_t nmonth, uint8_t nday, uint8_t nhour, uint8_t nminute, uint8_t nsecond);




void onunix(uint32_t stamp) {

};

    // hub.onCLI([](String str) {
    //     Serial.println(str);
    //     hub.sendCLI(str + "!");
    // });

void setup() { 
   LittleFS.begin();
  //  hub.onCLI(cli);
 Serial.begin(115200); 
 pinMode(vdnpin, OUTPUT);  // D10 как выход
digitalWrite(vdnpin,  LOW); // высокий сигнал на D10

pinMode(pwmv, OUTPUT);
//  PWM_resolution(pwmv, 8, FAST_PWM);

pwm27new=0;


sensors.begin();
  sensors.setResolution(insideThermometer, TEMPERATURE_PRECISION);
  sensors.setResolution(outsideThermometer, TEMPERATURE_PRECISION);
  sensors.setResolution(ROOMThermometer, TEMPERATURE_PRECISION);
   







 WiFi.mode(WIFI_STA);
    WiFi.begin(AP_SSID, AP_PASS);
    while (WiFi.status() != WL_CONNECTED) {
delay(500);
      // digitalWrite(vdnpin,  HIGH); // высокий сигнал на D10
        
        Serial.print(".");
    };
    Serial.println();
    Serial.println(WiFi.localIP());

    // hub.mqtt.config("test.mosquitto.org", 1883);


    hub.onBuild(build);

    // hub.onCLI([](String str) {
    //     Serial.println(str);
    //     hub.sendCLI(str + "!");
    // });

    hub.onInfo([](gh::Info& info) {
        switch (info.type) {
            case gh::Info::Type::Version:
                info.add("ur mom", "v3.14");
                break;
            case gh::Info::Type::Network:
                info.add(F("5G"), "50%");
                break;
            case gh::Info::Type::Memory:
                info.add(F("SD"), "10 GB");
                info.add(F("Int"), 100500);
                break;
            case gh::Info::Type::System:
                info.add(F("Battery"), 3.63, 2);
                break;
        }
    });

    hub.onRequest([](gh::Request& req) -> bool {
        Serial.print("Request: ");
        Serial.print(gh::readConnection(req.client.connection()));
        Serial.print(',');
        Serial.print(req.client.id);
        Serial.print(',');
        Serial.print(gh::readCMD(req.cmd));
        Serial.print(',');
        Serial.print(req.name);
        Serial.print(',');
        Serial.print(req.value);
        Serial.println();
        return 1;
    });

// #ifdef GH_ESP_BUILD
//     hub.onReboot([](gh::Reboot r) {
//         Serial.println(gh::readReboot(r));
//     });

//     hub.onFetch([](gh::Fetcher& f) {
//         // if (f.path == "/fetch_file.txt") f.fetchFile("/fetch_file.txt");
//         if (f.path == "/fetch_bytes.txt") f.fetchBytes((uint8_t*)fetch_bytes, strlen(fetch_bytes));
//         if (f.path == "/fetch_pgm.txt") f.fetchBytes_P((uint8_t*)fetch_pgm, strlen_P(fetch_pgm));
//     });

//     hub.onUpload([](String& path) {
//         Serial.print("Uploaded: ");
//         Serial.println(path);
//         if (path == "/data.dat") data2.begin();  // refresh from file
//     });
// #endif

    hub.begin();

    // data2.begin();
    Serial.println(hub.getUI());
    Serial.println(hub.getValues());
    hub.setBufferSize(2000);


  // WiFi.begin(ssid, password);
  //   while (WiFi.status() != WL_CONNECTED) {
  //       delay(500);
  //       Serial.println("Connecting to WiFi..");
  //   };
    Serial.println("Connected to the Wi-Fi network");
    //connecting to a mqtt broker
    client.setServer(mqtt_broker, mqtt_port);
    client.setCallback(callback);
    // while (!client.connected()) {
        String client_id = "esp32";
        client_id += String(WiFi.macAddress());
        Serial.printf("The client %s connects to the public MQTT broker\n", client_id.c_str());
       Serial.println(WiFi.localIP());
  // stamp = Stamps;
  //  Stamps = stamp;
    //  };


      // uint32_t unix = stamp.getUnix();
  //      Serial.println("unix");
  // Serial.println(unix);

     conFile.begin();  // прочитать из файла
// data2.begin();
//  data.begin();
//  rtc.begin();
  //  rtc.setTime(BUILD_SEC, BUILD_MIN, BUILD_HOUR, BUILD_DAY, BUILD_MONTH, BUILD_YEAR);

  //  rtc.setTime(COMPILE_TIME); 

// // stamp.setDateTime(2021, 1, 1, 0, 0, 0);
//   // uint32_t unix = stamp.getUnix();
//   unix = rtc.getUnix(3);
//   uint32_t stamp = unix.getUnix();
// 




  // Serial.begin(115200);
  //   Serial.print("Locating devices...");
  //  Serial.print("Found ");
  //  // Serial.print(sensors.getDeviceCount(), DEC);
  //  Serial.println(" devices.");

//     // start serial port

//    Serial.println("Dallas Temperature IC Control Library Demo");

//        if (client.connect(MQTT::Connect("arduinoClient2")
// .set_auth(mqtt_user, mqtt_pass))) {
// Serial.println("Connected to MQTT server");
// client.set_callback(callback);
// client.subscribe("test/led"); // подписывааемся по топик с данными для светодиода
// } else {
// Serial.println("Could not connect to MQTT server");
// }
 timeClient.begin();
  // Set offset time in seconds to adjust for your timezone, for example:
  // GMT +1 = 3600
  // GMT +8 = 28800
  // GMT -1 = -3600
  // GMT 0 = 0
  timeClient.setTimeOffset(10800);

 if (Temperatura == 0) {
Temperatura = 22.5;
};



    
if (client.connected()){
client.loop();
// TempSend();
};
       
       
      if (client.connect(client_id.c_str(), mqtt_username, mqtt_password)) {
            Serial.println("Public EMQX MQTT broker connected");
            
        // } 
        // else {
        //     Serial.print("failed with state ");
        //     Serial.print(client.state());
        //     delay(2000);
        };
  
  
  
  
  
    // }


    // Publish and subscribe
//     client.publish(topic, "Hi, I'm ESP32 ^^");
//     client.subscribe(topic);
//  Serial.print(topic);


//     // подключение к роутеру
//     WiFi.mode(WIFI_STA);
//     WiFi.begin(AP_SSID, AP_PASS);
//     while (WiFi.status() != WL_CONNECTED) {
//         delay(500);
//         Serial.print(".");
//     }
//     Serial.println();
//     Serial.println(WiFi.localIP());
//  // запуск!
 
//  mqtt.begin(client);
// client.connect("m8.wqtt.ru", 14396);
// mqtt.connect("arduino", "public", "public");

    // hub.begin();
    // если нужен MQTT - подключаемся
    // hub.mqtt.config("test.mosquitto.org", 1883);
    // hub.mqtt.config("test.mosquitto.org", 1883, "login", "pass");
// hub.mqtt.config("m8.wqtt.ru", 14396, "wootang", "398958");
  // указать префикс сети, имя устройства и иконку
    hub.config(F("TP-LINK"), F("testesp32"), F(""));

    // подключить билдер
    hub.onBuild(build_Menu);

   
  hub.setVersion("v1.12");      // установить версию (отображается в info)
  hub.setPIN(3989);            // установить пин-код
  hub.sendGetAuto(true); 


     button.begin(BUTTON_PIN);
     // pinMode(BUTTON_PIN);
   button.setLongClickTime(3000);
   button.setDoubleClickTime(300);
  button.setChangedHandler(changed);
    button.setPressedHandler(pressed);
   button.setReleasedHandler(released);

   // button.setTapHandler(tap);
   button.setClickHandler(click);
   button.setLongClickDetectedHandler(longClickDetected);
   button.setLongClickHandler(longClick);
   button.setLongClickDetectedRetriggerable(false);
  
   button.setDoubleClickHandler(doubleClick);
   button.setTripleClickHandler(tripleClick);
  
 pcf1.begin();
  pcf2.begin();


 
pwm27=120;
 analogWrite(pwmv, 120); 



 // #define P00  	0
 // 	#define P01  	1
 // 	#define P02  	2
 // 	#define P03  	3
 // 	#define P04  	4
 // 	#define P05  	5
 // 	#define P06  	6
 // 	#define P07  	7
 // 	#define P10  	8
 // 	#define P11  	9
 // 	#define P12  	10
 // 	#define P13  	11
 // 	#define P14  	12
 // 	#define P15  	13
 // 	#define P16  	14
 // 	#define P17  	15
 	pcf1.pinMode(P0, OUTPUT);
   pcf1.pinMode(P1, OUTPUT);
   pcf1.pinMode(P2, OUTPUT);
   pcf1.pinMode(P3, OUTPUT);
   pcf1.pinMode(P4, OUTPUT);
   pcf1.pinMode(P5, OUTPUT);
   pcf1.pinMode(P6, OUTPUT);
   pcf1.pinMode(P7, OUTPUT);
   pcf1.pinMode(P8, OUTPUT);
   pcf1.pinMode(P9, OUTPUT);

 pcf1.pinMode(P10, OUTPUT);
 pcf1.pinMode(P11, OUTPUT);
 pcf1.pinMode(P12, OUTPUT);
 pcf1.pinMode(P15, OUTPUT);
 pcf1.pinMode(P14, OUTPUT);
 pcf1.pinMode(P13, OUTPUT);

 pcf1.digitalWrite(P0, HIGH);


 	pcf1.digitalWrite(P1, HIGH);



 	pcf1.digitalWrite(P2, HIGH);

 	pcf1.digitalWrite(P3, HIGH);
	
 	pcf1.digitalWrite(P4, HIGH);

 	pcf1.digitalWrite(P5, HIGH);

 	pcf1.digitalWrite(P6, HIGH);

 	pcf1.digitalWrite(P7, HIGH);

 	pcf1.digitalWrite(P8, HIGH);

 	pcf1.digitalWrite(P9, HIGH);


   	pcf1.digitalWrite(P10, HIGH);

   	pcf1.digitalWrite(P11, HIGH);

 	pcf1.digitalWrite(P12, HIGH);

      	pcf1.digitalWrite(P13, HIGH);

     	pcf1.digitalWrite(P14, HIGH);

     	pcf1.digitalWrite(P15, LOW);



 	pcf2.pinMode(P0, INPUT);
   pcf2.pinMode(P1, INPUT);
   pcf2.pinMode(P2, INPUT);
   pcf2.pinMode(P3, INPUT);
   pcf2.pinMode(P4, INPUT);
   pcf2.pinMode(P5, INPUT);
   pcf2.pinMode(P6, INPUT);
   pcf2.pinMode(P7, INPUT);
   pcf2.pinMode(P8, INPUT);
   pcf2.pinMode(P9, INPUT);

 pcf2.pinMode(P10, INPUT);
 pcf2.pinMode(P11, INPUT);
 pcf2.pinMode(P12, INPUT);
 pcf2.pinMode(P15, INPUT);
 pcf2.pinMode(P14, INPUT);
 pcf2.pinMode(P13, INPUT);



//  pcf2.digitalWrite(P0, LOW);


//  	pcf2.digitalWrite(P1, LOW);



//  	pcf2.digitalWrite(P2, LOW);

//  	pcf2.digitalWrite(P3, LOW);
	
//  	pcf2.digitalWrite(P4, LOW);

//  	pcf2.digitalWrite(P5, LOW);

//  	pcf2.digitalWrite(P6, LOW);

//  	pcf2.digitalWrite(P7, LOW);

//  	pcf2.digitalWrite(P8, LOW);

//  	pcf2.digitalWrite(P9, LOW);


//    	pcf2.digitalWrite(P10, LOW);

//    	pcf2.digitalWrite(P11, LOW);

//  	pcf2.digitalWrite(P12, LOW);

//       	pcf2.digitalWrite(P13, LOW);

//      	pcf2.digitalWrite(P14, LOW);

//      	pcf2.digitalWrite(P15, LOW);


    // pinMode(ventpin, OUTPUT); // объявляем  вывод ШИМ как выход:

 tmrWF.setTimerMode();
 tmrWF.setPeriodMode();
 tmr.setPeriodMode();
//  tmr2.setPeriodMode();
 textp.setPeriodMode();
tmrvent.setPeriodMode();
//  hub.onUnix(onunix);




  // dolivSENS = LOW;

  //  waterSENS = LOW;
 
//  pinMode(35, INPUT); // СЕНСОР ДОЛИВА
//  pinMode(32, INPUT);    // СЕНСОР ПОДАЧИ ВОДЫ (ВЕРХ)
 pinMode(19, INPUT); //sens 1
 pinMode(25, INPUT);

 
  
  // ======== УСТАНОВКА ВРЕМЕНИ ВРУЧНУЮ ========    
  // установить время вручную можно двумя способами (подставить реальные числа)
  //rtc.setTime(SEC, MIN, HOUR, DAY, MONTH, YEAR);
  //rtc.setHMSDMY(HOUR, MIN, SEC, DAY, MONTH, YEAR);
  
  // также можно установить время через DateTime
  
  

  
  // rtc.setTime(now);  // загружаем в RTC

//       hub.onUnix([](uint32_t stamp) {
//     //   Serial.println("stamp");
//     //     Serial.println(stamp);


//     // Serial.println("stamp2");
//     //     Serial.println(Stamp);

// // Stamp = stamp+10800;
// //  Serial.println("now");
//         // Serial.println(DateTime);
//  uint32_t getUnix();  
//     });


obogrevt=0;
obogrev=0;
  
   ThingSpeak.begin(espClient);

//  u8g2.clearBuffer();


    

  //   Serial.print("data:");
  //   Serial.println(conFile["key"]);
   
  //   conFile["Wtemp"] = Wtemp;  // изменили
  //   conFile["Rtemp"] = Rtemp;  // изменили


  //   Serial.print("daty:");
  //   Serial.println(conFile["Wtemp"]);
  //  Serial.println(conFile["Rtemp"]);

//  p["key0"] = "string literal";
//     p[F("key1")] = F("F string");
//     String s("String");
//     p[String("key") + 2] = s;
//     p["key3"] = sutil::AnyText((const __FlashStringHelper*)pstr);
//     p["key4"] = true;
//     p["key5"] = 12345;
//     p["key6"] = 12345789ull;
//     p["key7"] = 3.14;
//     p["key8"] = sutil::AnyValue(3.141527, 6);



//  // вывести в любой тип
//     char buf[20];
//     p["key2"].toStr(buf);
//     String ss = p["key3"];
//     bool b = p["key4"];
//     int i = p["key5"];
//     uint64_t u64 = p["key6"];
//     float f = p["key7"];
//     double d = p["key8"];

//     Serial.println(buf);
//     Serial.println(ss);
//     Serial.println(b);
//     Serial.println(i);
//     // Serial.println(u64);
//     Serial.println(f);
//     Serial.println(d, 6);

//     Serial.println("==========");

//     // удаление
//     p.remove("key0");
//     p.remove(F("key1"));
//     p.remove(String("key") + 2);
//     p.removeN(0);  // 3
//     p.removeN(0);  // 4
//     p.removeN(0);  // 5
//     p.removeN(p.amount() - 1);  // 8
//     Serial.println(p);
//   Serial.println(p);


// 




};


void loop()
 {


timeClient.update();
 sensors.requestTemperatures();
   float Wtempl=sensors.getTempC(insideThermometer);

 
float Rtempl=sensors.getTempC(outsideThermometer);
 
float Rtempl2=sensors.getTempC(ROOMThermometer);




  if  (Wtempl >=10 && Wtempl <=50) {
 Wtemp = Wtempl;};

 if  (Rtempl >=10 && Rtempl <=50) {
 Rtemp = Rtempl;};

 if  (Rtempl2 >=10 && Rtempl <=50) {
 Rtemp2 = Rtempl2;};





  time_t epochTime = timeClient.getEpochTime();
  // Serial.print("Epoch Time: ");
  // Serial.println(epochTime);
  
  String formattedTime = timeClient.getFormattedTime();
  // Serial.print("Formatted Time: ");
  // Serial.println(formattedTime);  

  int currentHour = timeClient.getHours();
  // Serial.print("Hour: ");
  // Serial.println(currentHour);  

  int currentMinute = timeClient.getMinutes();
  // Serial.print("Minutes: ");
  // Serial.println(currentMinute); 
   
  int currentSecond = timeClient.getSeconds();
  // Serial.print("Seconds: ");
  // Serial.println(currentSecond);  

  String weekDay = weekDays[timeClient.getDay()];
  // Serial.print("Week Day: ");
  // Serial.println(weekDay);    

  //Get a time structure
  struct tm *ptm = gmtime ((time_t *)&epochTime); 

  int monthDay = ptm->tm_mday;
  // Serial.print("Month day: ");
  // Serial.println(monthDay);

  int currentMonth = ptm->tm_mon+1;
  // Serial.print("Month: ");
  // Serial.println(currentMonth);

  String currentMonthName = months[currentMonth-1];
  // Serial.print("Month name: ");
  // Serial.println(currentMonthName);

  int currentYear = ptm->tm_year+1900;
  // Serial.print("Year: ");
  // Serial.println(currentYear);

  //Print complete date:
  String currentDate = String(currentYear) + "-" + String(currentMonth) + "-" + String(monthDay);
  // Serial.print("Current date: ");
  // Serial.println(currentDate);
 Stamps = timeClient.getEpochTime();

 stamp.getDateTime(Stamps);


 float venttime = currentHour;


  // Serial.println("");
//  Serial.println();
  val_utechkaD = digitalRead(19);

dolivSENS = pcf2.digitalRead(P0);
waterSENS = pcf2.digitalRead(P1);   


  podachawater =  pcf1.digitalRead(P3);
       polivpompa = !pcf1.digitalRead(P1);
    dolivpompa = pcf1.digitalRead(P0);
 volt = 10000/255*pwm27/1000;

  // u8g2.drawStr(0,10,"Hello World!");	// write something to the internal memory
  // u8g2.drawStr(0,50,"Wootang GO!");


pwm100 = pwm27/255*100;
// Serial.println("vdnpin");
// Serial.println(digitalRead(vdnpin));
//   delay(5000);
 // высокий сигнал на D10

//      sensors.requestTemperatures();
//    float Wtempl=sensors.getTempC(insideThermometer);

//    sensors.requestTemperatures();
// float Rtempl=sensors.getTempC(outsideThermometer);

  
  // добавить меню и 
//  if (grelka == 1) {
//        pcf8575.digitalWrite(P2, LOW);
//     };
//  data.tick();
//  data2.tick();
//  if (grelka == 0) {
//        pcf8575.digitalWrite(P2, HIGH);
//     };
//  conFile.tick();  // тикаем тут. Само обновится после таймаута






   venttime = currentHour;
 
//  Serial.println();
if ( venttime >=ventup &&  venttime <=ventdown){
        //  ventday;
        // if (ventday == 0){
        //   ventday = 10;
        // ventday = 40;
        ventdd = 1;
   }; 




if (venttime <= ventup &&  venttime >= ventdown){

ventdd = 0;
};


 if (ventdd == 1) {
ventday = 20;

        if (ventel == 0) {
   pwm27 = ventob0 + ventday;
//  analogWrite(ventpin, pwm27); 
  // pwm.write(pwmv, pwm27);
  //  pwm.analogWrite(pwmv, pwm27);
   analogWrite(pwmv, pwm27); 
   };

   if (ventel == 1) {
     pwm27 = ventob1 + ventday;
  // analogWrite(ventpin, pwm27); 
  analogWrite(pwmv, pwm27);  };

     if (ventel == 2) {
         pwm27 = ventob2 + ventday;
  //  analogWrite(ventpin, pwm27); 
  analogWrite(pwmv, pwm27); 
 };
       if (ventel == 3) {
         pwm27 = ventob3 + ventday;
  // analogWrite(ventpin, pwm27); 
      analogWrite(pwmv, pwm27); 
 };

         if (ventel == 4) {
             pwm27 = ventob4 + ventday;
  // analogWrite(ventpin, pwm27); 
      analogWrite(pwmv, pwm27); 
 };
           if (ventel == 5) {
             pwm27 = ventob5 + ventday;
  // analogWrite(ventpin, pwm27); 
      analogWrite(pwmv, pwm27); 
 };
             if (ventel == 6) {
                 pwm27 = ventob6 + ventday;
  // analogWrite(ventpin, pwm27); 
       analogWrite(pwmv, pwm27); 
 };

             if (ventel == 7) {
                 pwm27 = ventob7 + ventday;
  // analogWrite(ventpin, pwm27); 
      analogWrite(pwmv, pwm27); 
 };

  if (ventel == 8) {
     pwm27 = ventob8 + ventday;
  // analogWrite(ventpin, pwm27); 
    analogWrite(pwmv, pwm27); 
 };

  if (ventel == 9) {
     pwm27 = ventob9 + ventday;
  // analogWrite(ventpin, pwm27); 
   analogWrite(pwmv, pwm27); 
 };
 };
    //      Serial.println("ventday-");
    //  Serial.print(ventday);
    //  Serial.println("");
      
      
//   else  { 
//     // ventday = 0;
//    	Serial.println("ventday-");
//      Serial.print(ventday);
    //  };
//       Serial.println("");
// ventday = 0;


//  };


 if (ventdd == 0){
   
          ventday = 0;
        // if (ventday == 0){
        //   ventday = 10;
       
       if (ventel == 0) {
   pwm27 = ventob0;
//  analogWrite(ventpin, pwm27); 
     analogWrite(pwmv, pwm27); 
   };

   if (ventel == 1) {
     pwm27 = ventob1;
  // analogWrite(ventpin, pwm27); 
    analogWrite(pwmv, pwm27);  };

     if (ventel == 2) {
         pwm27 = ventob2;
  //  analogWrite(ventpin, pwm27); 
    analogWrite(pwmv, pwm27); 
      };
        if (ventel == 3) {
         pwm27 = ventob3;
  // analogWrite(ventpin, pwm27); 
    analogWrite(pwmv, pwm27); 
 };
         if (ventel == 4) {
             pwm27 = ventob4;
  // analogWrite(ventpin, pwm27); 
   analogWrite(pwmv, pwm27);  };
           if (ventel == 5) 
           {
             pwm27 = ventob5;
  // analogWrite(ventpin, pwm27); 
     analogWrite(pwmv, pwm27); 
 };
             if (ventel == 6) {
                 pwm27 = ventob6;
  // analogWrite(ventpin, pwm27); 
      analogWrite(pwmv, pwm27); 
 };

             if (ventel == 7) {
                 pwm27 = ventob7;
  // analogWrite(ventpin, pwm27); 
       analogWrite(pwmv, pwm27); 
 };

  if (ventel == 8) {
     pwm27 = ventob8;
  // analogWrite(ventpin, pwm27); 
     analogWrite(pwmv, pwm27); 
 };

  if (ventel == 9) {
     pwm27 = ventob9;
  // analogWrite(ventpin, pwm27); 
    analogWrite(pwmv, pwm27); 

  };       
  // };
 };

//  hub.onUnix(onunix);

  


 
  if (pwm27new != pwm27) {

    pwm27new = pwm27;
Serial.print("Обороты-");Serial.println(pwm27);
  };

 

if (ventel != ventel) {
   Serial.println("Vent-");
Serial.print(ventel);


 Serial.println("");
 };


 // Дата. Параметры: value(unix), color, disabled, attach, click + параметры виджета
// Widget& Date(AnyPtr ptr);
// Widget& Date_(AnyText name, AnyPtr ptr);

// // Время. Параметры: value(unix), color, disabled, attach, click + параметры виджета
// Widget& Time(AnyPtr ptr);
// Widget& Time_(AnyText name, AnyPtr ptr);

// // Дата и время. Параметры: value(unix), color, disabled, attach, click + параметры виджета
// Widget& DateTime(AnyPtr ptr);
// Widget& DateTime_(AnyText name, AnyPtr ptr);
  // float venttime = now.hour;
  //  if ( venttime >=ventup &&  venttime <=ventdown){
  // if (ventday == 0){
  //         ventday = 10;
  // };
  //  };
   


//   //      u8g2.begin();
//   //        u8g2.clearBuffer();					// clear the internal memory
//   // u8g2.setFont(u8g2_font_ncenB08_tr);	// choose a suitable font
//   // u8g2.drawStr(0,10,"Hello World!");	// write something to the internal memory
//   // u8g2.drawStr(0,50,"Wootang GO!");
//   // u8g2.sendBuffer();					// transfer internal memory to the display

// //  u8g2.setI2CAddress (0x3F * 2);  //(); 0x7E  0x3F  0x3F * 2
// //    u8g2.begin(); 
// //   u8g2.setContrast(120);
// //    u8g2.setFontMode(1);
// //         u8g2.clearBuffer(); // clear the internal memory
// //         // u8g2.setFont(u8x8_font_chroma48medium8_r);
// //         u8g2.setFont(u8g2_font_ncenB08_tr); 
// //       //  u8g2.InverseFont(1); 
// //   u8g2.drawStr(15, 10, "Wootang"); // write something to the internal memory
// //         u8g2.drawStr(30, 25, "with 128x64"); // write something to the internal memory
// //         u8g2.drawStr(20, 45, "ST7567S display"); // write something to the internal memory
// //         u8g2.drawStr(0, 60, "using Arduino u8g2lib"); // write something to the internal memory
// // u8g2.sendBuffer(); // transfer internal memory to the display
// // //  u8g2.clearBuffer(); // clear the internal memory 
//  //  sensors.begin();



// //  u8g2.clearBuffer(); // clear the internal memory

// // u8g2.enableUTF8Print();
// // u8g2.setFont(u8g2_font_4x6_tr);
// // u8g2.sendBuffer();

// // u8g2
// // u8g2
// //  u8g2.setDrawColor(0);
// //  u8g2.setContrast(0);
//         // u8g2.clearBuffer(); // clear the internal memory
//         // u8g2.setFont(u8x8_font_chroma48medium8_r);
//         // u8g2.setFont(u8g2_font_ncenB08_tr);
// //  u8g2.setFontDirection(0);
// //             u8g2.setCursor(5, 5);
// // u8g2.print(currentHour);
// // u8g2.print(":");

// // u8g2.setCursor(10, 5);
// //    u8g2.print(currentMinute);
// // u8g2.print(":");
// // u8g2.setCursor(20, 5);
// //    u8g2.print(currentSecond);
// // u8g2.print(":");

// u8g2.setFont(u8g2_font_ncenB08_tr);
// // u8g2.setFont(u8g2_font_4x6_tr);
// // u8g2.setFont(u8g2_font_ncenB14_tr);


//  u8g2.setCursor(10, 20);
//   u8g2.print(Wtemp);

//  u8g2.setCursor(15, 24);
//   u8g2.print("TR*-");
//    u8g2.setCursor(25, 24);
//   u8g2.print(Rtemp);

//  u8g2.setCursor(25, 31);
//   u8g2.print("TR.-");
//    u8g2.setCursor(35, 31);
//   u8g2.print(Rtemp2);


// u8g2.sendBuffer();

//   if (tmrug.tick()){
  hub.tick();
//   // clear the internal memory

// u8g2.clearBuffer();

//   }

// =========== ОБНОВЛЕНИЯ ПО ТАЙМЕРУ ===========
    // в библиотеке предусмотрен удобный класс асинхронного таймера
    static gh::Timer tmr(1000);  // период 1 секунда

    // каждую секунду будем обновлять заголовок
    if (tmr) {
        hub.update(F("title")).value(millis());
    };



   button.loop();




// dolivSENS = dolivSE;
// waterSENS = waterSE;
  //    Serial.println("waterSENS");

  // Serial.println(waterSENS);
  // Serial.println("dolivSENS");
  // Serial.println(dolivSENS);  
 

 
  // int  dolivSENS = pcf2.digitalRead(P0);

//  int  waterSENS = pcf2.digitalRead(P1);


 

//  u8g2.clearBuffer(); // clear the internal memory
//  u8g2.setDrawColor(0);
// //  u8g2.setContrast(0);
//         // u8g2.clearBuffer(); // clear the internal memory
//         u8g2.setFont(u8x8_font_chroma48medium8_r);
//         // u8g2.setFont(u8g2_font_ncenB08_tr);
//  u8g2.setFontDirection(0);
//             u8g2.setCursor(0, 0);
// u8g2.print( now.hour);
// u8g2.print(":");

// u8g2.setCursor(20, 0);
//    u8g2.print( now.minute);
// u8g2.print(":");
// u8g2.setCursor(40, 0);
//    u8g2.print( now.second);
// // u8g2.print(":");
//   // clear the internal memory
// u8g2.sendBuffer();








 // Устанавливаем текущее время
   CurrentTimeWS = millis();
   // считываем сенсор
   boolean CurrentStateWS = waterSENS;
   // если текущее состояние сенсора отличается считанного
   if (CurrentStateWS != SensorStateWS) {
     // если отсчет таймера смены состояния не начат, начинаем
     if (SensorStartChangeWS == 0) SensorStartChangeWS = CurrentTimeWS;
     // если новое состояние приняло свое значение за время большее чем время таймаута
     if (CurrentTimeWS - SensorStartChangeWS > TIMEOUTWS) {
         // меняем состояние сенсора
         SensorStateWS=!SensorStateWS;
         // сбрасываем время начала смены состояния
         SensorStartChangeWS = 0;
         // если текущее состояние сенсора 1, то включаем светодиод
         if(SensorStateWS){
           	pcf1.digitalWrite(P3, HIGH);
         // если текущее состояние сенсора 0, то выключаем светодиод
         }else{
          pcf1.digitalWrite(P3, LOW);
         }
     }
   // смена состояния не состоялась, сбрасываем таймер
   }else{
     SensorStartChangeWS = 0;
   };


 // Устанавливаем текущее время
   CurrentTimeDS = millis();
   // считываем сенсор
   boolean CurrentStateDS = dolivSENS;
   // если текущее состояние сенсора отличается считанного
   if (CurrentStateDS != SensorStateDS) {
     // если отсчет таймера смены состояния не начат, начинаем
     if (SensorStartChangeDS == 0) SensorStartChangeDS = CurrentTimeDS;
     // если новое состояние приняло свое значение за время большее чем время таймаута
     if (CurrentTimeDS - SensorStartChangeDS > TIMEOUTDS) {
         // меняем состояние сенсора
         SensorStateDS=!SensorStateDS;
         // сбрасываем время начала смены состояния
         SensorStartChangeDS = 0;
         // если текущее состояние сенсора 1, то включаем светодиод
         if(SensorStateDS){
           	pcf1.digitalWrite(P0, HIGH);
         // если текущее состояние сенсора 0, то выключаем светодиод
         }else{
          pcf1.digitalWrite(P0, LOW);
         }
     }
   // смена состояния не состоялась, сбрасываем таймер
   }else{
     SensorStartChangeDS = 0;
   };



 if (poliv==1) {
     // Serial.println("poliv on");
    pcf1.digitalWrite(P1, LOW);
   };

 if (poliv==0) {
     // Serial.println("poliv oFF");
    pcf1.digitalWrite(P1, HIGH);
   };


 



//   if  (Wtempl >=10 && Wtempl <=50) {
//  Wtemp = Wtempl;};

//  if  (Rtempl >=10 && Rtempl <=50) {
//  Rtemp = Rtempl;};

//  if  (Rtempl2 >=10 && Rtempl <=50) {
//  Rtemp2 = Rtempl2;};


// Serial.println(Wtemp);
// Serial.println(Rtemp);
// Serial.println(Rtemp2);






 if (tmr.tick()){
 
  
  
 
 float grelkatime = currentHour;
  // if (grelkatime >=10.00 && grelkatime <=21.00){
     if (Wtemp < Temperatura && Wtemp >= 11  ) {
obogrevt=1;
  }
   else  {
   	obogrevt=0;
  };
      if (obogrev==1 && obogrevt==1) { 
   	pcf1.digitalWrite(P2, LOW);
    //  grelka = 1;    && obogrev==1
     //  Serial.println(grelkatime);
 
     }
     else  {
   	pcf1.digitalWrite(P2, HIGH);
    //  grelka = 0;

   }
  };


 



 if (autos == 1) {

    if (Rtemp <= vent0 && Rtemp <= vent1 ) {
 ventel=0;
   
   };

     if (Rtemp >= vent1 && Rtemp <= vent2 ) {
   ventel=1;
   
   };

  if (Rtemp >= vent2 && Rtemp <= vent3) {
 ventel=2;;
     
   };

  if (Rtemp >= vent3 && Rtemp <= vent4) {
 ventel=3;
    
   };


    if (Rtemp >= vent4 && Rtemp <= vent5) {
 	ventel=4;
    
   };


    if (Rtemp >= vent5 && Rtemp <= vent6) {
 	ventel=5;
 
   };

    if (Rtemp >= vent6 && Rtemp <= vent7) {
   	ventel=6;
    
    };
    
     if (Rtemp >= vent7 && Rtemp <= vent8) {
 	ventel=7;
      
     };


  if (Rtemp >= vent8 && Rtemp <= vent9) {
 	ventel=8;
    
   };
    if (Rtemp >= vent9) {
 	ventel=9;
      
     };

 

 };
  
 
// u8g2.setContrast(120);
//         u8g2.clearBuffer(); // clear the internal memory
//         u8g2.setFont(u8g2_font_ncenB08_tr);
// //  String se=strcmp(waterSENS);

// //   // Serial.println(waterSENS.atoi(key));    // 123
//  u8g2.setCursor(10,0);
// u8g2.print("WS-");

//  u8g2.setCursor(10,10);
// u8g2.print(waterSENS);
// u8g2.sendBuffer();
//    u8g2.print( now.minute);
// u8g2.print(":");
//    u8g2.print( now.second);
// u8g2.print(":");
  // clear the internal memory



//    lcd.cursor(0 ,2);
//    lcd.display("WS-");
//    lcd.cursor(3, 2);
//    lcd.display(String&se);

  //    lcd.cursor(0, 3);
  //  lcd.display("DS-");
  //  lcd.cursor(3, 3);
  //  lcd.display(dolivSENS);

  // lcd.cursor(10, 0);
  //  lcd.display("W-");
  //  lcd.cursor(12, 0);
  //  lcd.display(Wtemp, 2);

  //  lcd.cursor(0,1);
  //  lcd.display("220-");
  //  lcd.cursor(4,1);
  //  lcd.display(val_utechkaD);

  // lcd.cursor(10, 1);
  //  lcd.display("R-");
  //  lcd.cursor(12, 1);
  //  lcd.display(Rtemp, 2);



  // lcd.cursor(12, 2);
  //  lcd.display("T-");
  //  lcd.cursor(15, 2);
  //  lcd.display(Temperatura, 2);



//   int pwm27;
   
 if (tmrWF.tick()){


   Serial.println("SENDED");

  ThingSpeak.setField(1, Wtemp);
   ThingSpeak.setField(2, Rtemp);
    ThingSpeak.setField(3, waterSENS);
   ThingSpeak.setField(4, Rtemp2);

    ThingSpeak.setField(5, grelka);
   ThingSpeak.setField(6, podachawater);
    ThingSpeak.setField(7, dolivpompa);
  ThingSpeak.setField(8, polivpompa);

   ThingSpeak.writeFields(CHANNEL_ID, CHANNEL_API_KEY);


  ThingSpeak.setField(1, ventel);
   ThingSpeak.setField(2, digitalRead(19));
    ThingSpeak.setField(3, waterSENS);
   ThingSpeak.setField(4, dolivSENS);

    ThingSpeak.setField(5, grelka);
   ThingSpeak.setField(6, podachawater);
    ThingSpeak.setField(7, dolivpompa);
   ThingSpeak.setField(8, ventel);
 //  ThingSpeak.setField(9, ventel);
   ThingSpeak.writeFields(CHANNEL_ID2, CHANNEL_API_KEY2);


 };





  if (textp.tick()){


  if (ventel==0) {

     Serial.println("VENT-0");
  //        lcd.cursor(10, 3);
  //  lcd.display("V-0");
  // (char(223));
   };

     if (ventel==1) {

      Serial.println("VENT-1");
  //       lcd.cursor(10, 3);
  //  lcd.display("V-1");

   };

  if (ventel==2) {
 
         Serial.println("VENT-2");
  //            lcd.cursor(10, 3);
  //  lcd.display("V-2");
            

   };

  if (ventel==3) {
 
         Serial.println("VENT-3");
        
  //  lcd.cursor(10, 3);
  //  lcd.display("V-3");
 

 
   };


    if (ventel==4) {
 	
         Serial.println("VENT-4");
        
  //    lcd.cursor(10, 3);
  //  lcd.display("V-4");
 

 
   };


    if (ventel==5) {

         Serial.println("VENT-5");
        
  //   lcd.cursor(10, 3);
  //  lcd.display("V-5");
 

 
   };



    if (ventel==6) {
  
         Serial.println("VENT-6");
  //             lcd.cursor(10, 3);
  //  lcd.display("V-6");

    };
    




     if (ventel==7) {
 	
         Serial.println("VENT-7");
        
  //      lcd.cursor(10, 3);
  //  lcd.display("V-7");
     };


  if (ventel==8) {
 
         Serial.println("VENT-8");
        
  //      lcd.cursor(10, 3);
  //  lcd.display("V-8");

   };
    if (ventel==9) {
 
         Serial.println("VENT-9");
        
  //      lcd.cursor(10, 3);
  //  lcd.display("V-9");
     };



  if  (Wtemp >=10) {
     Serial.print("℃ W(*C): ");
   Serial.print(Wtemp, 3);
 
  
   Serial.println();
    };

  if  (Rtemp >=10) {
     Serial.print("℃ верх(*C): ");
   Serial.print(Rtemp, 3);
     Serial.println();
   };
 
 if  (Rtemp2 >=10 && Rtemp2 <=50) {
     Serial.print("℃ низ(): ");
   Serial.print(Rtemp2, 3);
    Serial.println();
   };


  Serial.print("Кипятильник-");
  if  (pcf1.digitalRead(P3) == 1) {
     Serial.println("ВКЛ ");
  // pcf1.digitalWrite(P2, LOW);
   }
     else  {
        Serial.println("ВЫКЛ ");
   };




//  Serial.print("НИЖНИЙ УРОВНЯ ВОДЫ--");
  if  (dolivSENS == 1) {
     Serial.println("Растворный бак полон");
  
   }
     else  {
       Serial.println("Растворный бак требуется долить");
   };




//  Serial.print("СЕНСОР ВЕРХНИЙ УРОВНЯ ВОДЫ---");
  if  (waterSENS == 1) {
     Serial.println("Бак воды полон");
  
   };
    if  (waterSENS == 0) {
       Serial.println("Бак воды требуется долить");
   };


//  Serial.print("Помпа на долив--");
  if  (dolivpompa ==0) {
     Serial.println("Помпа чистой ВКЛ");
  
   }
     else 
      {
       Serial.println("Помпа чистой ВЫКЛ");
   };

//  Serial.print("Помпа на Полив--");
  if  (polivpompa ==0) {
     Serial.println("Помпа на Полив ВЫКЛ");
  
   }
     else  {
       Serial.println("Помпа на ПоливВКЛ ");
   };

//  Serial.print("Подача воды с фильтра--");
  if  (podachawater ==0) {
     Serial.println("Подача воды с фильтра ВКЛ ");
  
   }
     else  {
       Serial.println("Подача воды с фильтра ВЫКЛ ");
   };




 Serial.print("переменная долива--");
  if  (DP >=0) {
     Serial.println(" ВКЛ ");
  
   }
     else  {
       Serial.println(" ВЫКЛ ");
   };

 if(digitalRead(19) == 0)
   {
  	pcf1.digitalWrite(P4, LOW);
     Serial.println("УТЕЧКА ВОДЫ/220 ОБЕСТОЧЕНО");
     Serial.println(" ");
   };


 if(digitalRead(19) == 1)
   {
   	pcf1.digitalWrite(P4, HIGH);
     Serial.println("УТЕЧКИ ВОДЫ НЕТ");
     Serial.println(" ");
   };



};


   Stamps = timeClient.getEpochTime();
//  stamp.getDateTime(Stamps);
  // Serial.println(Stamps);
  stamp.getDateTime(Stamps);
//  stamp = Stamps;
//  Serial.print(stamp);




// //  Serial.print("time   ");
//   Serial.print(stamp.hour);
//   Serial.print(":");
//   Serial.print(stamp.minute);
//   Serial.print(":");
//   Serial.print(stamp.second);
//   Serial.print("  ");

//    Serial.print(stamp.day);
//   Serial.print(".");
//  Serial.print(stamp.month); 
//  Serial.print(".");
//  Serial.print(stamp.year);
 
//   // Serial.print("----");
//   // Serial.print(stamp.dayOfWeek);

//  Serial.println();
//  int hour = stamp.hour;
//  };


//    float venttime = now.hour;
//    if ( venttime >=ventup &&  venttime <=ventdown){



//   if (ventday == 0){
//           ventday = 10;
//   };
//   //  };

//  };

//  stamp.getDateTime(Stamps);
//  Serial.println(stamp.year);
//   Serial.println(stamp.month);
//   Serial.println(stamp.day);
//   Serial.println(stamp.hour);
//   Serial.println(stamp.minute);
//   Serial.println(stamp.second);







  if (millis() - tmr1 >= (sending_period * 20000)) {
    tmr1 = millis();
    sendData();
    //  Stamps = timeClient.getEpochTime();
    //  Serial.println(Stamps);
  };

//  float venttime = hour;
   



   if (tmrvent.tick()) {  


//    Serial.print("venttime");
//  Serial.println(venttime);




 
  };






 conFile["Wtemp"] = Wtemp;  // изменили
    conFile["Rtemp"] = Rtemp;  // изменили

 conFile["Rtemp2"] = Rtemp2;  // изменили


    conFile["ventday"] = ventday;  // изменили
    conFile["volt"] = volt;  // изменили


        conFile["Temperatura"] = Temperatura;  // изменили
    conFile["pwm27"] = pwm27;  // изменили

  conFile["Stamp"] = Stamps;  // изменили


conFile["vent0"] = vent0;  // изменили
conFile["vent1"] = vent1;  // изменили
conFile["vent2"] = vent2;  // изменили
conFile["vent3"] = vent3;  // изменили
conFile["vent4"] = vent4;  // изменили
conFile["vent5"] = vent5;  // изменили
conFile["vent6"] = vent6;  // изменили
conFile["vent7"] = vent7;  // изменили
conFile["vent8"] = vent8;  // изменили
conFile["vent9"] = vent9;  // изменили


conFile["ventob0"] = ventob0;  // изменили
conFile["ventob1"] = ventob1;  // изменили
conFile["ventob2"] = ventob2;  // изменили
conFile["ventob3"] = ventob3;  // изменили
conFile["ventob4"] = ventob4;  // изменили
conFile["ventob5"] = ventob5;  // изменили
conFile["ventob6"] = ventob6;  // изменили
conFile["ventob7"] = ventob7;  // изменили
conFile["ventob8"] = ventob8;  // изменили
conFile["ventob9"] = ventob9;  // изменили
//   DateTime d = rtc.getTime();
conFile.tick();
// DateTime now = rtc.getTime();
//  d.minute = now.minute;
//   d.hour = now.hour;
//   d.day = now.day;
//   d.month = now.month;
// d.year = now.year;  // изменили год

//   d.second = now.second;



// DateTime now();
// stamp.getDateTime(now);
// now = timeClient.getEpochTime();
//   u8g2.print( 2, 8); u8g2.print(d.day);
//     u8g2.print( 7, 8); u8g2.print(d.day);
//     u8g2.print( 11, 8); u8g2.print(".");
//     u8g2.print( 15, 8); u8g2.print(d.month);
//     u8g2.print( 20, 8); u8g2.print(d.month);
//     u8g2.print( 24, 8); u8g2.print(".");
//     u8g2.print( 29, 8); u8g2.print(d.year);

//     u8g2.print( 101, 8); u8g2.print(d.hour);
//     u8g2.print( 107, 8); u8g2.print(d.hour);
//     u8g2.print( 112, 8); u8g2.print(":");
//     u8g2.print( 117, 8); u8g2.print(d.minute);
//     u8g2.print( 122, 8); u8g2.print(d.minute);

// Serial.print(stamp.toString());
// Serial.print(s);
// u8g2.sendBuffer();
//  u8g2.clearBuffer(); // clear the internal memory 

// u8g2.setContrast(255);
// //         u8g2.clearBuffer(); 
// //     u8g2.setCursor(0, 0);
// // u8g2.print( stamp.hour);
// // u8g2.print(":");

// // u8g2.setCursor(20, 0);
// //    u8g2.print( stamp.minute);
// // u8g2.print(":");
// // u8g2.setCursor(40, 0);
// //    u8g2.print( stamp.second);
// // u8g2.print(":");
//   // const char* Wtempa = conFile["Wtemp"];
//   // const char* Rtempa = conFile["Rtemp"];
//   // const char* Rtemp2a = conFile["Rtemp2"];
//   // const char* pwm27a = conFile["pwm27"];


//   // const char* Wtempa = Wtem;
//   // const char* Rtempa = Rtemp;
//   // const char* Rtemp2a = Rtemp2;
//   // const char* pwm27a = pwm27;
// // const char* Wtemp;
// // const char* Rtemp ;
// // const char* Rtemp2 ;
// //  const char* pwm27;
// //  Wtempa = conFile["Wtemp"];
// // Rtempa = conFile["Rtemp"];
// // Rtemp2a = conFile["Rtemp2"];
// //   pwm27a = conFile["pwm27"];



// //   int  Wtempa =  Wtemp;
// // str Wtempa;
// // //  int Rtempa=Rtemp;
// // //   int Rtemp2a=Rtemp2;
// // //   int pwm27a=pwm27;
// // char(Wtemp)[10] = conFile["Wtemp"];
// // Wtempa = atof(Wtemp);
// //  u8g2.drawStr( 0, 0, atof(Wtemp));
// //  u8g2.drawStr( 0, 20, Rtemp);
// //   u8g2.drawStr( 0, 70, Rtemp2);
// //    u8g2.drawStr( 0, 90, pwm27);



// u8g2.sendBuffer();

// // float WtempF = Wtemp;

// // float RtempF = Rtemp;

// // float Rtemp2F = Rtemp2;

// // float pwm27F = pwm27;

// // u8g2.clear();
// // u8g2.setFont(u8g2_font_ncenB08_tr);
// //  u8g2.setCursor(0, 0);
// //    u8g2.print(Wtemp);
// //  u8g2.setCursor(20, 0);
// // //  u8g2.print(float (Wtemp));
// //  u8g2.setCursor(40, 0);
// // u8g2.print("Rtemp2F");
// //  u8g2.setCursor(60, 0);
// // u8g2.print(pwm27F);
// //  u8g2.setCursor(90, 0);
// // u8g2.print(WtempF);
// // // u8g2.printf

// //   // u8g2.drawStr( 0, 0, WtempF&);
// // //  u8g2.drawStr( 0, 20, RtempF);
// // //   u8g2.drawStr( 0, 70, Rtemp2F);
// // //    u8g2.drawStr( 0, 90, pwm27F);
// // u8g2.sendBuffer();
// // delay(5000);

// // u8g2.nextPage();

// // u8g2.clearBuffer();
//   //   Serial.print("ventob9-");
//   //  Serial.println(conFile["ventob9"]);


//   //   Serial.print("vent9-");
//   //  Serial.println(conFile["vent9"]);

//   //   Serial.print("Wtemp:");
//   //   Serial.println(conFile["Wtemp"]);

//   //    Serial.print("Rtemp:");
//   //  Serial.println(conFile["Rtemp"]);

//   //     Serial.print("Rtemp2:");
//   //  Serial.println(conFile["Rtemp2"]);

//   //   Serial.print("ventday:");
//   //   Serial.println(conFile["ventday"]);

//   //    Serial.print("volt:");
//   //  Serial.println(conFile["volt"]);

//   //      Serial.print("Temperatura:");
//   //   Serial.println(conFile["Temperatura"]);

//   //    Serial.print("pwm27:");
//   //  Serial.println(conFile["pwm27"]);
 
// //  u8g2.clearBuffer();
// // u8g2.refreshDisplay();		// only required for SSD1606/7 
// }; 
// }; 


 
// #include <Arduino.h>


// #include <U8g2lib.h>
// #include <SPI.h>




// U8G2_ST7920_128X64_F_SW_SPI u8g2(U8G2_R0, /* clock=*/ 14, /* data=*/ 13, /* CS=*/ 15, /* reset=*/ 4); 




// void setup() {
//     Serial.begin(115200);
//     // delay(1500);
//     // Serial.println("\nADS1256 swipe " __FILE__ " " __TIMESTAMP__);

//        u8g2.begin();
//          u8g2.clearBuffer();					// clear the internal memory
//   u8g2.setFont(u8g2_font_ncenB08_tr);	// choose a suitable font
//   u8g2.drawStr(0,10,"Hello World!");	// write something to the internal memory
//   u8g2.drawStr(0,50,"Wootang GO!");
//   u8g2.sendBuffer();					// transfer internal memory to the display
//   delay(1000);  


//     }




// void loop()
//  {
  
//         //          Serial.print("0--");
          
//         //  Serial.println("--");
//         //  Serial.println("--");
       
//         u8g2.clear();

//   u8g2.clearBuffer();

//  // u8g2.setFont(u8g2_font_5x8_t_cyrillic);	// choose a suitable font 
// // u8g2.setFont(u8g2_font_synchronizer_nbp_tf);	// choose a suitable font 
//   u8g2.setFontMode(1);
//   u8g2.setCursor(0, 7);
//  u8g2.print("int0-");
//   delay(10000);  
//   //  u8g2.setCursor(35, 7);	
//   //   u8g2.print("4", 10);


  
//   u8g2.sendBuffer();

//            u8g2.clearBuffer();
//  }

 };
  // };